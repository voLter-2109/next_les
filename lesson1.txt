1.  Принципы SOLID — это набор из пяти основных принципов 
объектно-ориентированного проектирования, нацеленных на 
повышение качества кода путём улучшения его структуры, 
избавления от хрупкости и повышения гибкости. 

1. Принцип единственной ответственности (SRP)
Каждый класс должен иметь одну ответственность (функционал) и 
все его методы должны быть связаны с этой ответственностью. 
 
 2.  Принцип открытости-закрытости (OCP)
 Классы должны быть открыты для расширения, но закрыты для модификации. 
 наследуем родителя и дописываем методы, не меняя родителя

3. Принцип подстановки Барбары Лисков (LSP)
Функции, которые используют базовый тип, должны иметь 
возможность использовать подтипы базового типа, не зная об этом

4. Принцип разделения интерфейсов (ISP)
программные сущности не должны зависеть от методов, которые они не используют.
 Давайте теперь совсем просто — не нужно тащить в модуль то, что модуль 
не использует просто ради того, чтобы все красиво наследовалось

5. Принцип инверсии зависимостей (DIP)
Другими словами, один компонент не должен напрямую зависеть от другого компонента,
 а скорее они оба должны зависеть от некоторой общей абстракции.
  Здесь «компонент» относится к любой части нашего приложения, 
будь то компонент React, служебная функция, модуль или сторонняя библиотека.

Например создание промежуточного родительского компонента а далее через пропсы 
и так их можно тестировать отдельно

2. Основные принципы ООП
Инкапсуляция /  Наследование / Полиморфизм

___________________________________________________________________________
1. В JavaScript есть 8 основных типов данных.

Семь из них называют «примитивными» типами данных:
number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
bigint для целых чисел произвольной длины.
string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
boolean для true/false.
null для неизвестных значений – отдельный тип, имеющий одно значение null.
undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
symbol для уникальных идентификаторов.

И один не является «примитивным» и стоит особняком:
object для более сложных структур данных.

___________________________________________________________________________
2. 
"" + 1 + 0
"" - 1 + 0
true + false
6 / "3"
"2" * "3"
4 + 5 + "px"
"$" + 4 + 5
"4" - 2
"4px" - 2
"  -9  " + 5
"  -9  " - 5
null + 1
undefined + 1

"" + 1 + 0 = "10" // (1)
"" - 1 + 0 = -1 // (2)
true + false = 1
6 / "3" = 2
"2" * "3" = 6
4 + 5 + "px" = "9px"
"$" + 4 + 5 = "$45"
"4" - 2 = 2
"4px" - 2 = NaN
"  -9  " + 5 = "  -9  5" // (3)
"  -9  " - 5 = -14 // (4)
null + 1 = 1 // (5)
undefined + 1 = NaN // (6)

Неявное преобразование типов и явное преобразование типов
таблица:
https://dorey.github.io/JavaScript-Equality-Table/
статья: 
https://habr.com/ru/companies/ruvds/articles/347866/

В строку (String)
В логическое значение (Boolean)
В число (Number)

String(123) // явное преобразование
123 + ''    // неявное преобразование

Boolean(2)          // явное преобразование
if (2) { ... }      // неявное преобразование в логическом контексте
!!2                 // неявное преобразование логическим оператором
2 || 'hello'        // неявное преобразование логическим оператором

Number('123')   // явное преобразование
+'123'          // неявное преобразование ----- унарный плюс
123 != '456'    // неявное преобразование
4 > '5'         // неявное преобразование
5/null          // неявное преобразование
true | 0        // неявное преобразование

true + false
12 / "6"
"number" + 15 + 3
15 + 3 + "number"
[1] > null
"foo" + + "bar"
'true' == true
false == 'false'
null == ''
!!"false" == !!"true"
[‘x’] == ‘x’
[] + null + 1
0 || "0" && {}
[1,2,3] == [1,2,3]
{}+[]+{}+[1]
!+[]+[]+![]
new Date(0) - 0
new Date(0) + 0

true + false // 1
12 / "6" // 2
"number" + 15 + 3 // 'number155'
15 + 3 + "number" // '18number'
[1] > null // true
"foo" + + "bar" // 'fooNan'
'true' == true // false
false == 'false' // false
null == '' // false
!!"false" == !!"true" // true
[‘x’] == ‘x’ // true
[] + null + 1 // 'null1'
0 || "0" && {} // {}
[1,2,3] == [1,2,3] // false
{}+[]+{}+[1] // 0[object Object]1
!+[]+[]+![] // 'truefalse'
new Date(0) - 0 // 0
new Date(0) + 0 // 'Thu Jan 01 1970 03:00:00 GMT+0300 (Москва, стандартное время)0'

___________________________________________________________________________

null обозначает намеренное отсутствие значения объекта (объект без заданной структуры), 
а undefined — что переменной (не объекту) ещё не присвоено значение

alert( null === undefined ); // false
alert( null == undefined ); // true

alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true

'null || 2 || undefined   // 2 - находит первое истинное значение
1 && null && 2 // null - находит первое ложное значение

___________________________________________________________________________
3. отличия стрелочной функции от функции-выражения

В отличие от традиционного объявления, стрелочные функции не имеют собственного элемента this ,
поскольку значение this внутри стрелочной функции остается неизменным на протяжении всего жизненного
цикла функции и всегда привязано к значению this в ближайшей традиционной родительской функции.

В JavaScript «контекст вызова» (this) в функции указывает на объект, которым была вызвана функция. 
Для функциональных компонентов в React специфических примеров использования this нет, так как 
функциональные компоненты не привязываются непосредственно к контексту в отличие от классовых компонентов.
Однако, понимание того, как работает контекст со стрелочными функциями, может быть полезно
в других ситуациях, например, если вы используете стрелочные функции внутри обработчиков
событий или методов, например, в хуках.

пример на главной странице page.tsx

let person = {
  name: "Ernane Ferreira",
  sayMyName: () => console.log(`My name is ${this.name}.`),
};

person.sayMyName(); // => My name is .


4. Копирование объектов и ссылки, копирование через замыкание

function createObjectCloner() {
  return function cloneObject(obj) {
    // Создаем клон изначально пустым объектом
    const clonedObj = {};

    // Итерируемся по всем ключам переданного объекта
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        // Если значение — объект, рекурсивно клонируем.
        // Это полезно для глубокого клонирования вложенных объектов.
        if (typeof obj[key] === 'object' && obj[key] !== null) {
          clonedObj[key] = cloneObject(obj[key]);
        } else {
          // Иначе, просто присваиваем значение
          clonedObj[key] = obj[key];
        }
      }
    }

    return clonedObj;
  };
}

const clone = createObjectCloner();
const user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

const clonedUser = clone(user);

console.log(clonedUser);
console.log(clonedUser.sizes === user.sizes); // false, чтобы подтвердить, что это глубокая копия
___________________________________________________________________________

 3. какие ты знаешь хуки и какие они бывают? что такое хуки высшего порядка

4. Что такое виртуальный DOM?

5. Чем управляемые компоненты отличаются от неуправляемых?

6. В чем разница между классовыми и функциональными компонентами?


// ! отличия между session storage / local storage и cookie?

//     Срок хранения:

// LocalStorage: Долговременное хранение.
// SessionStorage: Временное хранение (до закрытия вкладки).
// Cookies: Настраиваемый срок действия.
// Объем хранения:

// LocalStorage: 5-10 МБ.
// SessionStorage: 5-10 МБ.
// Cookies: 4 КБ.
// Доступность:

// LocalStorage: Доступно из любого окна или вкладки.
// SessionStorage: Доступно только в текущей вкладке.
// Cookies: Доступно на сервере и клиенте.



7. Что такое методы жизненного цикла компонента
  
  // ! Что такое пробрасывание пропсов (props drilling)?
  // ! Что такое реквизиты в React? props

  // ! Что такое менеджер состояний и с какими из них вы работали?
  // * redux (Flux) - какой паттерн используется / useState / setState / context - когда лучше использовать и какой
  

  // ! Как отследить размонтирование функционального компонента
  
  // ! Для чего и как используется UseMemo - что такое мемоизация и как его испоьзовать на функциях
  

  // ! Что такое условный рендеринг?
  Этот метод , для управления тем, что должно отображаться на экране 
  в зависимости от состояния приложения или данных.
  
  if или &&
  
  // ! Что такое однонаправленный поток данных, какие есть альтернативы

  // ! Какие архитектурные решения для React вы знаете?
  Компонентный подход
  Контейнерные и презентационные компоненты
  Управление состоянием
  Модульная архитектура
  Файловая структура
  Server-Side Rendering (SSR)
  Static Site Generation (SSG)
  Micro-frontend архитектура

  // ! зачем нужен lazy import


  // ! мини задача https://habr.com/ru/companies/tensor/articles/779718/
  //   Почему первый URL может не вернуть данные:
  // Предположим, что начальная загрузка (для первого URL) ещё не завершена, когда произойдёт изменение URL.

  // Как только второй URL передаётся, useEffect запускается снова, что вызывает новый fetch запрос и одновременно вызывает функцию очистки предыдущего эффекта.
  // Эта функция очистки выставляет cancelled первого запроса в true.
  // Теперь, если первый запрос вернёт ответ после очистки, состояния компонента не будут обновлены, так как код проверяет флаг !cancelled перед изменением состояния.
  // Таким образом, данные от первого запроса игнорируются во избежание изменения состояния после начала обработки второго запроса.
  // Это поведение предотвращает "утечку" данных из отменённых запросов и исключает ситуацию, когда результат устаревшего запроса может перезаписать данные от нового запроса.

  // 1) Хуки можно использовать только в функциональных компонентах или в кастомных хуках.
  // 2) Хуки не должны вызываться в циклах или операторах ветвления, проще запомнить что хуки должны вызываться только на верхнем уровне


function useFetch(url) {
   const [data, setData] = useState(null);
   const [isLoading, setIsLoading] = useState(false);
   const [error, setError] = useState(null);

   useEffect(() => {
      // флаг отмены
      let cancelled = false;

      setIsLoading(true);
      setData(null);
      setError(null);
      fetch(url)
         .then((res) => res.json())
         .then((respData) => {
            if (!cancelled) setData(respData);
         })
         .catch((e) => {
            if (!cancelled) setError(e);
         })
         .finally(() => {
            if (!cancelled) setIsLoading(false);
         });

      return () => {
         // выставим признак того, что запрос отменен
         cancelled = true;
      };
   }, [url]);

   return [data, isLoading, error];

   ___________________________________________________________________________
   Делегирование событий
   завязано на всплытии

   То есть, event.stopPropagation() препятствует продвижению события дальше, но на 
   текущем элементе все обработчики будут вызваны.

Для того, чтобы полностью остановить обработку, существует метод event.stopImmediatePropagation().
 Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

products/page.tsx

 Event Loop

 Event Loop является стеком, где хранятся все задачи, которые не вошли в синхронный поток 
 выполнения. После завершения синхронного потока - задачи начинают выполняться из Event Loop'а.
  Однако у Event Loop'а тоже есть свои правила. Он делит все задачи на подтипы:

Микрозадачи
Макрозадачи
Задачи отрисовки

Макрозадачами являются все асинхронные операции, такие как XmlHTTPRequest, 
setTimeout и так далее.
В микрозадачи попадают в основном только две категории: then у промисов, 
а также Intersection Observer.
В задачи отрисовки попадают задачи связанные с отрисовкой и обновлением контента страницы.

Мы можем наглядно рассмотреть как Event Loop делает решения о том какую задачу брать
 и выполнять первой.

Сначала Event Loop проверяет выполнились ли все синхронные задачи
Потом выполняются все задачи из микротасков
После выполнения всех микротасков - очередь очищается
Затем мы берем одну макрозадачу из списка и выполняем ее
После выполнения мы смотрим нужно ли нам сделать перерисовку страницы
Если перерисовать страницу нужно - делаем это
Все снова начинается с первого пункта :)


console.log("Step 1: In global scope")

setTimeout(() => console.log("Step 2: In setTimeout"));

new Promise((resolve) => {
  console.log('Step 3: In promise constructor');
}).then(() => console.log('Step 4: In then'))
  .then(() => console.log('Step 5: In another then'));

setTimeout(() => console.log("Step 6: In another setTimeout"))

Step 1: In global scope
Step 3: In promise constructor
Step 4: In then
Step 5: In another then
Step 2: In setTimeout
Step 6: In another setTimeout

----> image.png
_________________________________

setTimeout(() => console.log('Step 1: In setTimeout'));

new Promise(resolve => {
  console.log('Step 2: In promise constructor');
  resolve();
}).then(() => {
  console.log('Step 3: In then');
  setTimeout(() => console.log('Step 4: In setTimeout (inside of "then")'));
});

setTimeout(() => console.log('Step 5: In another setTimeout'));

Step 2: In promise constructor
Step 3: In then
Step 1: In setTimeout
Step 5: In another setTimeout
Step 4: In setTimeout (inside of "then")